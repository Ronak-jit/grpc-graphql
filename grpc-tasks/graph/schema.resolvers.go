package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"log"

	"github.com/Ronak-Searce/grpc-tasks/graph/model"
	pb "github.com/Ronak-Searce/grpc-tasks/users/proto"
	"google.golang.org/grpc"
)

const (
	address = "localhost:50051"
)

// CreatUser is the resolver for the creatUser field.
func (r *mutationResolver) CreatUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	conn, err := grpc.Dial(address, grpc.WithInsecure(),
		grpc.WithBlock())
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	defer conn.Close()
	client := pb.NewUsererviceClient(conn)

	req := &pb.UserInfo{FirstName: input.Firstname, LastName: input.Lastnamwe}
	res, err := client.CreatUser(ctx, req)
	if err != nil {
		return &model.User{}, fmt.Errorf("error while creating user: %v", err)
	}
	user := &model.User{
		ID:        res.Id,
		Firstname: res.FirstName,
		Lastnamwe: res.LastName,
	}

	return user, nil

}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.ExistingUser) (*model.Status, error) {
	conn, err := grpc.Dial(address, grpc.WithInsecure(),
		grpc.WithBlock())
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	defer conn.Close()
	client := pb.NewUsererviceClient(conn)

	req := &pb.UserInfo{FirstName: input.Firstname, LastName: input.Lastnamwe, Id: input.ID}
	res, err := client.UpdateUser(ctx, req)

	if err != nil {
		return &model.Status{Status: int(-1)}, fmt.Errorf("error while updating user: %v", err)
	}
	return &model.Status{Status: int(res.Value)}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, input model.IDInput) (*model.Status, error) {

	conn, err := grpc.Dial(address, grpc.WithInsecure(),
		grpc.WithBlock())
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	defer conn.Close()
	client := pb.NewUsererviceClient(conn)

	req := &pb.Id{Value: input.ID}
	res, err := client.DeleteUser(ctx, req)

	if err != nil {
		return &model.Status{}, fmt.Errorf("error while creating user: %v", err)
	}

	return &model.Status{Status: int(res.Value)}, nil

}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, input string) (*model.User, error) {
	conn, err := grpc.Dial(address, grpc.WithInsecure(),
		grpc.WithBlock())
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	defer conn.Close()
	client := pb.NewUsererviceClient(conn)

	req := &pb.Id{Value: input}

	res, err := client.GetUser(ctx, req)

	if err != nil {
		return &model.User{}, fmt.Errorf("error while creating user: %v", err)
	}
	user := &model.User{
		ID:        res.Id,
		Firstname: res.FirstName,
		Lastnamwe: res.LastName,
	}
	return user, nil

}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: GetUsers - getUsers"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
